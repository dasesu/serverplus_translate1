====PAGE==== 1
An operating system is a program that manages a computer's hardware. It
also provides a basis for application programs and acts as an intermediary
between the computer user and the computer hardware. An amazing aspect of
operating systems is how they vary in accomplishing these tasks. Mainframe
operating systems are designed primarily to optimize utilization of hardware.
Personal computer (PC) operating systems support complex games, business
applications, and everything in between. Operating systems for mobile com-
puters provide an environment in which a user can easily interface with the
computer to execute programs. Thus, some operating systems are designed to
be convenient, others to be efficient, and others to be some combination of the
two.

Before we can explore the details of computer system operation, we need to
know something about system structure. We thus discuss the basic functions
of system startup, I/O, and storage early in this chapter. We also describe
the basic computer architecture that makes it possible to write a functional
operating system.

Because an operating system is large and complex, it must be created
piece by piece. Each of these pieces should be a well-delineated portion of the
system, with carefully defined inputs, outputs, and functions. In this chapter,
we provide a general overview of the major components of a contemporary
computer system as well as the functions provided by the operating system.
Additionally, we cover several other topics to help set the stage for the
remainder of this text: data structures used in operating systems, computing
environments, and open-source operating systems.
====PAGE==== 2
From the computer's point of view, the operating system is the program
most intimately involved with the hardware. In this context, we can view
an operating system as a resource allocator. A computer system has many
resources that may be required to solve a problem: CPU time, memory space,
file-storage space, I/O devices, and so on. The operating system acts as the
manager of these resources. Facing numerous and possibly conflicting requests
for resources, the operating system must decide how to allocate them to specific
programs and users so that it can operate the computer system efficiently and
fairly. As we have seen, resource allocation is especially important where many
users access the same mainframe or minicomputer.

A slightly different view of an operating system emphasizes the need to
control the various I/O devices and user programs. An operating system is a
control program. A control program manages the execution of user programs
to prevent errors and improper use of the computer. It is especially concerned
with the operation and control of I/O devices.
====PAGE==== 3
The CPU can load instructions only from memory, so any programs to run must
be stored there. General-purpose computers run most of their programs from
rewritable memory, called main memory (also called random-access memory,
or RAM). Main memory commonly is implemented in a semiconductor
technology called dynamic random-access memory (DRAM).

Computers use other forms of memory as well. We have already mentioned
read-only memory, ROM) and electrically erasable programmable read-only
memory, EEPROM). Because ROM cannot be changed, only static programs, such
as the bootstrap program described earlier, are stored there. The immutability
of ROM is of use in game cartridges. EEPROM can be changed but cannot
be changed frequently and so contains mostly static programs. For example,
smartphones have EEPROM to store their factory-installed programs.
====PAGE==== 4
Storage is only one of many types of I/O devices within a computer. A large
portion of operating system code is dedicated to managing I/O, both because
of its importance to the reliability and performance of a system and because of
the varying nature of the devices. Next, we provide an overview of I/O.

A general-purpose computer system consist of CPUs and multiple device
controllers that are connected through a common bus. Each device controller
is in charge of a specific type of device. Depending on the controller, more
than one device may be attached. For instance, seven or more devices can be
attached to the small computer-systems interface (SCSI) controller. A device
controller maintains some local buffer storage and a set of special-purpose
registers. The device controller is responsible for moving the data between
the peripheral devices that it controls and its local buffers storage. Typically,
operating systems have a device driver for each device controller. This device
driver understands the device controller and provides the rest of the operating
system with a uniform interface to the device.
====PAGE==== 5
Within the past several years, multiprocessor systems (also known as parallel
systems or multicore systems) have begun to dominate the landscape of
computing. Such systems have two or more processors in close communication,
sharing the computer bus and sometimes the clock, memory, and peripheral
devices. Multiprocessor systems first appeared prominently appeared in
servers and have since migrated to desktop and laptop systems. Recently,
multiple processors have appeared on mobile devices such as smartphones
and tablet computers.

Multiprocessor systems have three main advantages:

	1. Increased throughput. By increasing the number of processors, we expect
	to get more work done in less time. The speed-up ratio with N processors
	is not N, however; rather, it is less than N. When multiple processors
	cooperate on a task, a certain amount of overhead is incurred in keeping
	all the parts working correctly. This overhead, plus contention for shared
	resources, lowers the expected gain from additional processors. Similarly,
	N programmers working closely together do not produce N times the
	amount of work a single programmer would produce.
	
	2. Economy of scale. Multiprocessor systems can cost less than equivalent
	multiple single-processor systems, because they can share peripherals,
	mass storage, and power supplies. If several programs operate on the
	same set of data, it is cheaper to store those data on one disk and to have
	all the processors share them than to have many computers with local
	disks and many copies of the data.

	3. Increased reliability. If functions can be distributed properly among
	several processors, then the failure of one processor will not halt the
	system, only slow it down. If we have ten processors and one fails, then
	each of the remaining nine processors can pick up a share of the work of
	the failed processor. Thus, the entire system runs only 10 percent slower,
	rather than failing altogether.
====PAGE==== 6
Beowulf clusters are designed to solve high-performance computing tasks,
A Beowulf cluster consists of commodity hardware--such as personal
computers--connected via a simple local-area network. No single specific
software package is required to consutrct a cluster. Rather, the nodes use a 
et of open-source software libraries to communicate with one another. Thus,
there are a variety of approaches to constructing a Beowulf cluster. Typically,
though, Beowulf computing nodes run the Linux operating system. Since
Beowolf clusters require no special hardware and operate using open-source
software that is available free, they offer a low-cost strategy for building
a high-performance computing cluster. In fact, some Beowulf clusters built
from discarded personal computers are using hundreds of nodes to solve
computationally expensive scientific computing problems.
====PAGE==== 7
As mentioned earlier, modern operating systems are interrupt driven. If there
are no processes to execute, no I/O devices to service, and no users to whom
to respond, an operating system will sit quietly, waiting for something to
happen. Events are almost always signaled by the occurrence of an interrupt
or a trap. A trap (or an exception) is a software-generated interrupt caused
either by an error (for example, division by zero or invalid memory access)
or by a specific request from a user program that an operating-system service
be performed. The interrupt-driven nature of an operating system defines
that system's general structure. For each type of interrupt, separate segments
of code in the operating system determine what action should be taken. An
interrupt service routine is provided to deal with the interrupt.

Since the operating system and the users share the hardware and software
resources of the computer system, we need to make sure that an error in a
user program could cause problems only for the one program running. With
sharing, many processes could be adversely affected by a bug in one program.
For example, if a process gets stuck in an infinite loop, this loop could prevent
the correct operation of many other processes. More subtle errors can occur
in a multiprogramming system, where one erroneous program might modify
another program, the data of another program, or even the operating system
itself.

Without protection against these sorts of errors, either the computer must
execute only one process at a time or all output must be suspect. A properly
designed operating system must ensure that an incorrect (or malicious)
program cannot cause other programs to execute incorrectly.
====PAGE==== 8
At system boot time, the hardware starts in kernel mode. The operating
system is then loaded and starts user applications in user mode. Whenever a
trap or interrupt occurs, the hardware switches from user mode to kernel mode
(that is, changes the state of the mode bit to 0). Thus, whenever the operating
system gains control of the computer, it is in kernel mode. The system always
switches to user mode (by setting the mode bit to 1) before passing control to
a user program.

The dual mode of operation provides us with the means for protecting the
operating system from errant users--and errant users from one another. We
accomplish this protection by designating some of the machine instructions that
may cause harm as privileged instructions. The hardware allows privileged
instructions to be executed only in kernel mode. If an attempt is made to
execute a privileged instruction in user mode, the hardware does not execute
the instruction but rather treats it as illegal and traps it to the operating system.

The instruction to switch to kernel mode is an example of a privileged
instruction. Some other examples include I/O control, timer management, and
interrupt management. As we shall see throughout the text, there are many
additional privileged instructions.
====PAGE==== 9
The lack of a hardware-supported dual mode can cause serious shortcom-
ings in an operating system. For instance, MS-DOS was written for the Intel
8088 architecture, which has no mode bit and therefore no dual mode. A user
program running awry can wipe out the operating system by writing over it
with data; and multiple programs are able to write to a device at the same
time, with potentially disastrous results. Modern versions of the Intel CPU
do provide dual-mode operation. Accordingly, most contemporary operating
systems--such as Microsoft Windows 7, as well as Unix and Linux--take
advantage of this dual-mode feature and provide greater protection for the
operating system.

Once hardware protection is in place, it detects errors that violate modes.
These errors are normally handled by the operating system. If a user program
fails in some way--such as by making an attempt either to execute an illegal
instruction or to access memory that is not in the user's address space--then
the hardware traps to the operating system. The trap transfers control through
the interrupt vector to the operating system, just as an interrupt does. When
a program error occurs, the operating system must terminate the program
abnormally. This situation is handled by the same code as a user-requested
abnormal termination. An appropriate error message is given, and the memory
of the program may be dumped. The memory dump is usually written to a
file so that the user or programmer can examine it and perhaps correct it and
restart the program.
====PAGE==== 10
We must ensure that the operating system maintains control over the CPU.
We cannot allow a user program to get stuck in an infinite loop or to fail
to call system services and never return control to the operating system. To
accomplish this goal, we can use a timer. A timer can be set to interrupt
the computer after a specified period. The period may be fixed (for example,
1/60 second) or variable (for example, from 1 millisecond to 1 second). A
variable timer is generally implemented by a fixed-rate clock and a counter.
The operating system sets the counter. Every time the clock ticks, the counter
is decremented. When the counter reaches 0, an interrupt occurs. For instance,
a 10-bit counter with a 1-millisecond clock allows interrupts at intervals from
1 millisecond to 1,024 milliseconds, in steps of 1 millisecond.
====PAGE==== 11
Before turning over control to the user, the operating system ensures
that the timer is set to interrupt. If the timer interrupts, control transfers
automatically to the operating system, which may treat the interrupt as a fatal
error or may give the program more time. Clearly, instructions that modify the
content of the timer are privileged.

We can use the timer to prevent a user program from running too long.
A simple technique is to initialize a counter with the amount of time that a
program is allowed to run. A program with a 7-minute time limit, for example,
would have its counter initialized to 420. Every second, the timer interrupts,
and the counter is decremented by 1. As long as the counter is positive, control
is returned to the user program. When the counter becomes negative, the
operating system terminates the program for exceeding the assigned time
limit.
====PAGE==== 12
A process needs certain resources--including CPU time, memory, files,
and I/O devices--to accomplish its task. These resources are either given to
the process when it is created or allocated to it while it is running. In addition
to the various physical and logical resources that a process obtains when it is
created, various initialization data (input) may be passed along. For example,
consider a process whose function is to display the status of a file on the screen
of a terminal. The process will be given the name of the file as an input and will
execute the appropriate instructions and system calls to obtain and display
the desired information on the terminal. When the process terminates, the
operating system will reclaim any reusable resources.
====PAGE==== 13
File management is one of the most visible components of an operating system.
Computers can store information on several different types of physical media.
Magnetic disk, optical disk, and magnetic tape are the most common. Each
of these media has its own characteristics and physical organization. Each
medium is controlled by a device, such as a disk drive or tape drive, that
also has its own unique characteristics. These properties include access speed,
capacity, data-transfer rate, and access method (sequential or random).

A file is a collection of related information defined by its creator. Commonly,
files represent programs (both source and object forms) and data. Data files may
be numeric, alphabetic, alphanumeric, or binary. Files may be free-form (for
example, text files), or they may be formatted rigidly (for example, fixed fields).
Clearly, the concept of a file is an extremely general one.

The operating system implements the abstract concept of a file by managing
mass-storage media, such as tapes and disks, and the devices that control them.
In addition, files are normally organized into directories to make them easier
to use. Finally, when multiple users have access to files, it may be desirable
to control which user may access a file and how that user may access it (for
example, read, write, append).
====PAGE==== 14
There are, however, many uses for storage that is slower and lower in
cost (and sometimes of higher capacity) than secondary storage. Backups of
disk data, storage of seldom-used data, and long-term archival storage are
some examples. Magnetic tape drives and their tapes and CD and DVD drives
and platters are typical tertiary storage devices. The media (tapes and optical
platters) vary between WORM (write-once, read-many-times) and RW (read-
write) formats.

Tertiary storage is not crucial to system performance, but it still must
be managed. Some operating systems take on this task, while others leave
tertiary-storage management to application programs. Some of the functions
that operating systems can provide include mounting and unmounting media
in devices, allocating and freeing the devices for exclusive use by processes,
and migrating data from secondary to tertiary storage.
====PAGE==== 15
In addition, internal programmable registers, such as index registers,
provide a high-speed cache for main memory. The programmer (or compiler)
implements the register-allocation and register-replacement algorithms to
decide which information to keep in registers and which to keep in main
memory.

Other caches are implemented totally in hardware. For instance, most
systems have an instruction cache to hold the instructions expected to be
executed next. Without this cache, the CPU would have to wait several cycles
while an instruction was fetched from main memory. For similar reasons, most
systems have one or more high-speed data caches in the memory hierarchy.
We are not concerned with these hardware-only caches in this text, since they
are outside the control of the operating system.
====PAGE==== 16
If a computer system has multiple users and allows the concurrent execution
of multiple processes, then access to data must be regulated. For that purpose,
mechanisms ensure that files, memory segments, CPU, and other resources can
be operated on by only those processes that have gained proper authoriza-
tion from the operating system. For example, memory-addressing hardware
ensures that a process can execute only within its own address space. The
timer ensures that no process can gain control of the CPU without eventually
relinquishing control. Device-control registers are not accessible to users, so
the integrity of the various peripheral devices is protected.

Protection, then, is any mechanism for controlling the access of processes
or users to the resources defined by a computer system. This mechanism must
provide means to specify the controls to be imposed and to enforce the controls.
====PAGE==== 17
Protection and security require the system to be able to distinguish among
all its users. Most operating systems maintain a list of user names and
associated user identifiers (user IDs). In Windows parlance, this is a security
ID (SID). These numerical IDs are unique, one per user. When a user logs
in to the system, the authentication stage determines the appropriate user ID for
the user. That user ID is associated with all of the user's processes and threads.
When an ID needs to be readable by a user, it is translated back to the user
name via the user name list.

In some circumstances, we wish to distinguish among sets of users rather
than individual users. For example, the owner of a file on a UNIX system may be
allowed to issue all operations on that file, whereas a selected set of users may
be allowed only to read the file. To accomplish this, we need to define a group
name and the set of users belonging to that group. Group functionality can
be implemented as a system-wide list of group names and group identifiers.
A user can be in one or more groups, depending on operating-system design
decisions. The user's group IDs are also included in every associated process
and thread.

In the course of normal system use, the user ID and group ID for a user
are sufficient. However, a user sometimes needs to escalate privileges to gain
extra permissions for an activity. The user may need access to a device that is
restricted, for example. Operating systems provide various methods to allow
privilege escalation. On UNIX, for instance, the setuid attribute on a program
causes that program to run with the user ID of the owner of the file, rather than
the current user's ID. The process runs with this effective UID until it turns off
the extra privileges or terminates.
====PAGE==== 18
An array is a simple data structure in which each element can be accessed
directly. For example, main memory is constructed as an array. If the data item
being stored is larger than one byte, then multiple bytes can be allocated to the
item, and the item is addressed as item number x item size. But what about
storing an item whose size may vary? And what about removing an item if the
relative positions of the remaining items must be preserved? In such situations,
arrays give way to other data structures.
====PAGE==== 19
Linked lists accommodate items of varying sizes and allow easy insertion
and deletion of items. One potential disadvantage of using a list is that
performance for retrieving a specified item in a list of size n is linear -- O(n),
as it requires potentially traversing all n elements in the worst case. Lists
are sometimes used directly by kernel algorithms. Frequently, though, they
are used for constructing more powerful data structures, such as stacks and
queues.

A stack is a sequentially ordered data structure that uses the last in, first
out (LIFO) principle for adding and removing items, meaning that the last item
placed onto a stack is the first item removed. The operations for inserting and
removing items from a stack are known as push and pop, respectively. An
operating system often uses a stack when invoking function calls. Parameters,
local variables, and the return address are pushed onto the stack when a
function is called; returning from the function call pops those items off the
stack.
====PAGE==== 20
A hash function takes data as its input, performs a numeric operation on this
data, and returns a numeric value. This numeric value can then be used as an
index into a table (typically an array) to quickly retrieve the data. Whereas
searching for a data item through a list of size n can require up to O(n)
comparisons in the worst case, using a hash function for retrieving data from
table can be as good as O(1) in the worst case, depending on implementation
details. Because of this performance, hash functions are used extensively in
operating systems.
====PAGE==== 21
As computing has matured, the lines separating many of the traditional com-
puting environments have blurred. Consider the "typical office environment."
Just a few years ago, this environment consisted of PCs connected to a network,
with servers providing file and print services. Remote access was awkward,
and portability was achieved by use of laptop computers. Terminals attached
to mainframes were prevalent at many companies as well, with even fewer
remote access and portability options.

The current trend is toward providing more ways to access these computing
environments. Web technologies and increasing WAN bandwidth are stretching
the boundaries of traditional computing. Companies establish portals, which
provide Web accessibility to their internal servers. Network computers (or
thin clients)--which are essentially terminals that understand web-based
computing--are used in place of traditional workstations where more security
or easier maintenance is desired. Mobile computers can synchronize with PCs
to allow very portable use of company information. Mobile computers can also
connect to wireless networks and cellular data networks to use the company's
Web portal (as well as the myriad other Web resources).

At home, most users once had a single computer with a slow modem
connection to the office, the Internet, or both. Today, network-connection
speeds once available only at great cost are relatively inexpensive in many
places, giving home users more access to more data. These fast data connections
are allowing home computers to serve up Web pages and to run networks that
include printers, client PCs, and servers. Many homes use firewalls to protect
their networks from security breaches.
====PAGE==== 22
Today, traditional time-sharing systems are uncommon. The same schedul-
ing technique is still in use on desktop computers, laptops, servers, and even
mobile computers, but frequently all the processes are owned by the same
user (or a single user and the operating system). User processes, and system
processes that provide services to the user, are managed so that each frequently
gets a slice of computer time. Consider the windows created while a user
is working on a PC, for example, and the fact that they may be performing
different tasks at the same time. Even a web browser can be composed of
multiple processes, one for each website currently being visited, with time
sharing applied to each web browser process.
====PAGE==== 23
Mobile computing refers to computing on handheld smartphones and tablet
computers. These devices share the distinguishing physical features of being
portable and lightweight. Historically, compared with desktop and laptop
computers, mobile systems gave up screen size, memory capacity, and overall
functionality in return for handheld mobile access to services such as e-mail
and web browsing. Over the past few years, however, features on mobile
devices have become so rich that the distinction in functionality between, say,
a consumer laptop and a tablet computer may be difficult to discern. In fact,
we might argue that the features of a contemporary mobile device allow it to
provide functionality that is either unavailable or impractical on a desktop or
laptop computer.
====PAGE==== 24
Today, mobile systems are used not only for e-mail and web browsing but
also for playing music and video, reading digital books, taking photos, and
recording high-definition video. Accordingly, tremendous growth continues
in the wide range of applications that run on such devices. Many developers
are now designing applications that take advantage of the unique features of
mobile devices, such as global positioning system (GPS) chips, accelerometers,
and gyroscopes. An embedded GPS chip allows a mobile device to use satellites
to determine its precise location on earth. That functionality is especially useful
in designing applications that provide navigation--for example, telling users
which way to walk or drive or perhaps directing them to nearby services, such
as restaurants. An accelerometer allows a mobile device to detect its orientation
with respect to the ground and to detect certain other forces, such as tilting
and shaking. In several computer games that employ accelerometers, players
interface with the system not by using a mouse or a keyboard but rather by
tilting, rotating, and shaking the mobile device! Perhaps more a practical use
of these features is found in augmented-reality applications, which overlay
information on a display of the current environment. It is difficult to imagine
how equivalent applications could be developed on traditional laptop or
desktop computer systems.
====PAGE==== 25
A distributed system is a collection of physically separate, possibly heteroge-
neous, computer systems that are networked to provide users with access to
the various resources that the system maintains. Access to a shared resource
increases computation speed, functionality, data availability, and reliability.
Some operating systems generalize network access as a form of file access, with
the details of networking contained in the network interface's device driver.
Others make users specifically invoke network functions. Generally, systems
contain a mix of the two modes--for example FTP and NFS. The protocols
that create a distributed system can greatly affect that system's utility and
popularity.

A network, in the simplest terms, is a communication path between
two or more systems. Distributed systems depend on networking for their
functionality. Networks vary by the protocols used, the distances between
nodes, and the transport media. TCP/IP is the most common network protocol,
and it provides the fundamental architecture of the Internet. Most operating
systems support TCP/IP, including all general-purpose ones. Some systems
support proprietary protocols to suit their needs. To an operating system, a
network protocol simply needs an interface device--a network adapter, for
example--with a device driver to manage it, as well as software to handle
data. These concepts are discussed throughout this book.
====PAGE==== 26
Networks are characterized based on the distances between their nodes.
A local-area network (LAN) connects computers within a room, a building,
or a campus. A wide-area network (WAN) usually links buildings, cities, or
countries. A global company may have a WAN to connect its offices worldwide,
for example. These networks may run one protocol or several protocols. The
continuing advent of new technologies brings about new forms of networks.
For example, a metropolitan-area network (MAN) could link buildings within
a city. BlueTooth and 802.11 devices use wireless technology to communicate
over a distance of several feet, in essence creating a personal-area network
(PAN) between a phone and a headset or a smartphone and a desktop computer.

The media to carry networks are equally varied. They include copper wires,
fiber strands, and wireless transmissions between satellites, microwave dishes,
and radios. When computing devices are connected to cellular phones, they
create a network. Even very short-range infrared communication can be used
for networking. At a rudimentary level, whenever computers communicate,
they use or create a network. These networks also vary in their performance
and reliability.
====PAGE==== 27
Another structure for a distributed system is the peer-to-peer (P2P) system
model. In this model, clients and servers are not distinguished from one
another. Instead, all nodes within the system are considered peers, and each
may act as either a client or a server, depending on whether it is requesting or
providing a service. Peer-to-peer systems offer an advantage over traditional
client-server systems. In a client-server system, the server is a bottleneck; but
in a peer-to-peer system, services can be provided by several nodes distributed
throughout the network.
====PAGE==== 28
Virtualization is a technology that allows operating systems to run as appli-
cations within other operating systems. At first blush, there seems to be
little reason for such functionality. But the virtualization industry is vast and
growing, which is a testament to its utility and importance.

Broadly speaking, virtualization is one member of a class of software
that also includes emulation. Emulation is used when the source CPU type
is different from the target CPU type. For example, when Apple switched from
the IBM Power CPU to the Intel x86 CPU for its desktop and laptop computers,
it included an emulation facility called "Rosetta," which allowed applications
compiled for the IBM CPU to run on the Intel CPU. That same concept can be
extended to allow an entire operating system written for one platform to run
on another. Emulation comes at a heavy price, however. Every machine-level
instruction that runs natively on the source system must be translated to the
equivalent function on the target system, frequently resulting in several target
instructions. If the source and target CPUs have similar performance levels, the
emulated code can run much slower than the native code.
====PAGE==== 29
A common example of emulation occurs when a computer language is
not compiled to native code but instead is either executed in its high-level
from or translated to an intermediate form. This is known as interpretation.
Some languages, such as BASIC, can be either compiled or interpreted. Java, in
contrast, is always interpreted. Interpretation is a form of emulation in that the
high-level language code is translated to native CPU instructions, emulating
not another CPU but a theorical virtual machine on which that language could
run natively. Thus, we can run Java programs on "Java virtual machines," but
technically those virtual machines are Java emulators.
====PAGE==== 30
Embedded computers are the most prevalent form of computers in existence.
These devices are found everywhere, from car engines and manufacturing
robots to DVDs and microwave ovens. They tend to have very specific tasks.
The systems they run on are usually primitive, and so the operating systems
provide limited features. Usually, they have little or no user interface, preferring
to spend their time monitoring and managing hardware devices, such as
automobile engines and robotic arms.


These embedded systems vary considerably. Some are general-purpose
computers, running standard operating systems--such as Linux--with
special-purpose applications to implement the functionality. Others are hard-
ware devices with a special-purpose embedded operating system providing
just the functionality desired. Yet others are hardware devices with application-
specific integrated circuits (ASICs) that perform their tasks without an operat-
ing system.
====PAGE==== 31
The use of embedded systems continues to expand. The power of these
devices, both as standalone units and as elements of networks and the web,
is sure to increase as well. Even now, entire houses can be computerized, so
that a central computer--either a general-purpose computer or an embedded
system--can control heating and lighting, alarm systems, and even coffee
makers. Web access can enable a home owner to tell the house to heat up
before she arrives home. Someday, the refrigerator can notify the grocery store
when it notices the milk is gone.

Embedded systems almost always run real-time operating systems. A
real-time system is used when rigid time requirements have been placed on
the operation of a processor or the flow of data; thus, it is often used as a
control device in a dedicated application. Sensors bring data to the computer.
The computer must analyze the data and possibly adjust controls to modify
the sensor inputs. Systems that control scientific experiments, medical imaging
systems, industrial control systems, and certain display systems are real-
time systems. Some automobile-engine fuel-injection systems, home-appliance
controllers, and weapon systems are also real-time systems.

A real-time system has well-defined, fixed time constraints. Processing
must be done within the defined constraints, or the system will fail. For
instance, it would not do for a robot arm to be instructed to halt after it had
smashed into the car it was building. A real-time system functions correctly
only if it returns the correct result within its time constraints. Contrast this
system with a time-sharing system, where it is desirable (but not mandatory)
to respond quickly, or a batch system, which may have no time constraints at
all.
====PAGE==== 32
Starting with the source code allows the programmer to produce binary
code that can be executed on a system. Doing the opposite--reverse engi-
neering the source code from the binaries--is quite a lot of work, and useful
items such as comments are never recovered. Learning operating systems by
examining the source code has other benefits as well. With the source code
in hand, a student can modify the operating system and then compile and
run the code to try out those changes, which is an excellent learning tool.
This text includes projects that involve modifying operating-system source
code, while also describing algorithms at a high level to be sure all important
operating-system topics are covered. Throughout the text, we provide pointers
to examples of open-source code for deeper study.

There are many benefits to open-source operating systems, including a
community of interested (and usually unpaid) programmers who contribute
to the code by helping to debug it, analyze it, provide support, and suggest
changes. Arguably, open-source code is more secure than closed-source code
because many more eyes are viewing the code. Certainly, open-source code has
bugs, but open-source advocates argue that bugs tend to be found and fixed
faster owing to the number of people using and viewing the code. Companies
that earn revenue from selling their programs often hesitate to open-source
their code, but Red Hat and a myriad of other companies are doing just that
and showing that commercial companies benefit, rather than suffer, when they
open-source their code. Revenue can be generated through support contracts
and the sale of hardware on which the software runs, for example.
====PAGE==== 33
BSD UNIX has a longer and more complicated history than Linux. It started in
1978 as a derivative of AT&T's UNIX. Releases from the University of California
at Berkeley (UCB) came in source and binary form, but they were not open-
source because a license from AT&T was required. BSD UNIX's development was
slowed by a lawsuit by AT&T, but eventually a fully functional, open-source
version, 4.4BSD-lite, was released in 1994.

Just as with Linux, there are many distributions of BSD UNIX, including
FreeBSD, NetBSD, OpenBSD, and DragonflyBSD. To explore the source code
of FreeBSD, simply download the virtual machine image of the version of
interest and boot it within VMware, as described above for Linux. The source
code comes with the distribution and is stored in /usr/src/. The kernel
source code is in /usr/src/sys. For example, to examine the virtual memory
implementation code in the FreeBSD kernel, see the files in /usr/src/sys/vm.

Darwin, the core kernel component of Mac OS X, is based on BSD
UNIX and is open-sourced as well. That source code is available from
http://www.opensource.apple.com/. Every Mac OS X release has its open-
source components posted at that site. The name of the package that contains
the kernel begins with "xnu." Apple also provides extensive developer tools,
documentation, and support at http://connect.apple.com. For more informa-
tion, see Appendix A.
====PAGE==== 34
Summary
An operating system is software that manages the computer hardware, as well
as providing an environment for application programs to run. Perhaps the
most visible aspect of an operating system is the interface to the computer
system it provides to the human user.

For a computer to do its job of executing programs, the programs must be in
main memory. Main memory is the only large storage area that the processor
can access directly. It is an array of bytes, ranging in size from millions to
billions. Each byte in memory has its own address. The main memory is usually
a volatile storage device that loses its contents when power is turned off or
lost. Most computer systems provide secondary storage as an extension of
main memory. Secondary storage provides a form of nonvolatile storage that
is capable of holding large quantities of data permanently. The most common
secondary-storage device is a magnetic disk, which provides storage of both
programs and data.

The wide variety of storage systems in a computer system can be organized
in a hierarchy according to speed and cost. The higher levels are expensive,
but they are fast. As we move down the hierarchy, the cost per bit generally
decreases, whereas the access time generally increases.

There are several different strategies for designing a computer system.
Single-processor systems have only one processor, while multiprocessor
systems contain two or more processors that share physical memory and
peripheral devices. The most common multiprocessor design is symmetric
multiprocessing (or SMP), where all processors are considered peers and run
independently of one another. Clustered systems are a specialized form of
multiprocessor systems and consist of multiple computer systems connected
by a local-area network.
====PAGE==== 35
Operating systems must also be concerned with protecting and securing the
operating system and users. Protection measures control the access of processes
or users to the resources made available by the computer system. Security
measures are responsible for defending a computer system from external or
internal attacks.

Several data structures that are fundamental to computer science are widely
used in operating systems, including lists, stacks, queues, trees, hash functions,
maps, and bitmaps.

Computing takes place in a variety of environments. Traditional computing
involves desktop and laptop PCs, usually connected to a computer network.
Mobile computing refers to computing on handheld smartphones and tablet
computers, which offer several unique features. Distributed systems allow
users to share resources on geographically dispersed hosts connected via
a computer network. Services may be provided through either the client-
server model or the peer-to-peer model. Virtualization involves abstracting
a computer's hardware into several different execution environments. Cloud
computing uses a distributed system to abstract services into a "cloud," where
users may access the services from remote locations. Real-time operating
systems are designed for embedded environments, such as consumer devices,
automobiles, and robotics.

The free software movement has created thousands of open-source projects,
including operating systems. Because of these projects, students are able to use
source code as a learning tool. They can modify programs and test them,
help find and fix bugs, and otherwise explore mature, full-featured operating
systems, compilers, tools, user interfaces, and other types of programs.

GNU/Linux and BSD UNIX are open-source operating systems. The advan-
tages of free software and open sourcing are likely to increase the number
and quality of open-source projects, leading to an increase in the number of
individuals and companies that use these projects.
====PAGE==== 36
An operating system provides the environment within which programs are
executed. Internally, operating systems vary greatly in their makeup, since
they are organized along many different lines. The design of a new operating
system is a major task. It is important that the goals of the system be well
defined before the design begins. These goals form the basis for choices among
various algorithms and strategies.

We can view an operating system from several vantage points. One view
focuses on the services that the system provides; another, on the interface that
it makes available to users and programmers; a third, on its components and
their interconnections. In this chapter, we explore all three aspects of operating
systems, showing the viewpoints of users, programmers, and operating system
designers. We consider what services an operating system provides, how they
are provided, how they are debugged, and what the various methodologies
are for designing such systems. Finally, we describe how operating systems
are created and how a computer starts its operating system.
====PAGE==== 37
System calls provide an interface to the services made available by an operating
system. These calls are generally available as routines written in C and
C++, although certain low-level tasks (for example, tasks where hardware
must be accessed directly) may have to be written using assembly-language
instructions.

Before we discuss how an operating system makes system calls available,
let's first use an example to illustrate how system calls are used: writing a
simple program to read data from one file and copy them to another file. The
first input that the program will need is the names of the two files: the input file
and the output file. These names can be specified in many ways, depending on
the operating-system design. One approach is for the program to ask the user
for the names. In an interactive system, this approach will require a sequence of
system calls, first to write a prompting message on the screen and then to read
from the keyboard the characters that define the two files. On mouse-based and
icon-based systems, a menu of file names is usually displayed in a window.
The user can then use the mouse to select the source name, and a window
can be opened for the destination name to be specified. This sequence requires
many I/O system calls.
====PAGE==== 38
Once the two file names have been obtained, the program must open the
input file and create the output file. Each of these operations requires another
system call. Possible error conditions for each operation can require additional
system calls. When the program tries to open the input file, for example, it may
find that there is no file of that name or that the file is protected against access.
In these cases, the program should print a message on the console (another
sequence of system calls) and then terminate abnormally (another system call).
If the input file exists, then we must create a new output file. We may find that
there is already an output file with the same name. This situation may cause
the program to abort (a system call), or we may delete the existing file (another
system call) and create a new one (yet another system call). Another option,
in an interactive system, is to ask the user (via a sequence of system calls to
output the prompting message and to read the response from the terminal)
whether to replace the existing file or to abort the program.

When both files are set up, we enter a loop that reads from the input file
(a system call) and writes to the output file (another system call). Each read
and write must return status information regarding various possible error
conditions. On input, the program may find that the end of the file has been
reached or that there was a hardware failure in the read (such as a parity error).
The write operation may encounter various errors, depending on the output
device (for example, no more disk space).
====PAGE==== 39
A process may need several resources to execute--main memory, disk drives,
access to files, and so on. If the resources are available, they can be granted,
and control can be returned to the user process. Otherwise, the process will
have to wait until sufficient resources are available.

The various resources controlled by the operating system can be thought
of as devices. Some of these devices are physical devices (for example, disk
drives), while others can be thought of as abstract or virtual devices (for
example, files). A system with multiple users may require us to first request()
a device, to ensure exclusive use of it. After we are finished with the device, we
release() it. These functions are similar to the open() and close() system
calls for files. Other operating systems allow unmanaged access to devices.
====PAGE==== 40
The first problem in designing a system is to define goals and specifications.
At the highest level, the design of the system will be affected by the choice of
hardware and the type of system: batch, time sharing, single user, multiuser,
distributed, real time, or general purpose.

Beyond this highest design level, the requirements may be much harder
to specify. The requirements can, however, be divided into two basic groups:
user goals and system goals.

Users want certain obvious properties in a system. The system should be
convenient to use, easy to learn and to use, reliable, safe, and fast. Of course,
these specifications are not particularly useful in the system design, since there
is no general agreement on how to achieve them.

A similar set of requirements can be defined by those people who must
design, create, maintain, and operate the system. The system should be easy to
design, implement, and maintain; and it should be flexible, reliable, error free,
and efficient. Again, these requirements are vague and may be interpreted in
various ways.
====PAGE==== 41
The separation of policy and mechanism is important for flexibility. Policies
are likely to change across places or over time. In the worst case, each change
in policy would require a change in the underlying mechanism. A general
mechanism insensitive to changes in policy would be more desirable. A change
in policy would then require redefinition of only certain parameters of the
system. For instance, consider a mechanism for giving priority to certain types
of programs over others. If the mechanism is properly separated from policy,
it can be used either to support a policy decision that I/O-intensive programs
should have priority over CPU-intensive ones or to support the opposite policy.
====PAGE==== 42
The only possible disadvantages of implementing an operating system in a
higher-level language are reduced speed and increased storage requirements.
This, however, is no longer a major issue in today's systems. Although an
expert assembly-language programmer can produce efficient small routines,
for large programs a modern compiler can perform complex analysis and apply
sophisticated optimizations that produce excellent code. Modern processors
have deep pipelining and multiple functional units that can handle the details
of complex dependencies much more easily than can the human mind.

As is true in other systems, major performance improvements in oper-
ating systems are more likely to be the result of better data structures and
algorithms than of excellent assembly-language code. In addition, although
operating systems are large, only a small amount of the code is critical to high
performance; the interrupt handler, I/O manager, memory manager, and CPU
scheduler are probably the most critical routines. After the system is written
and is working correctly, bottleneck routines can be identified and can be
replaced with assembly-language equivalents.
====PAGE==== 43
With proper hardware support, operating systems can be broken into pieces
that are smaller and more appropriate than those allowed by the original
MS-DOS and UNIX systems. The operating system can then retain much greater
control over the computer and over the applications that make use of that
computer. Implementers have more freedom in changing the inner workings
of the system and in creating modular operating systems. Under a top-
down approach, the overall functionality and features are determined and
are separated into components. Information hiding is also important, because
it leaves programmers free to implement the low-level routines as they see fit,
provided that the external interface of the routine stays unchanged and that
the routine itself performs the advertised task.
====PAGE==== 44
An operating-system layer is an implementation of an abstract object made
up of data and the operations that can manipulate those data. A typical
operating-system layer--say, layer M--consists of data structures and a set
of routines that can be invoked by higher-level layers. Layer M, in turn, can
invoke operations on lower-level layers.

The main advantage of the layered approach is simplicity of construction
and debugging. The layers are selected so that each uses functions (operations)
and services of only lower-level layers. This approach simplifies debugging
and system verification. The first layer can be debugged without any concern
for the rest of the system, because, by definition, it uses only the basic hardware
(which is assumed correct) to implement its functions. Once the first layer is
debugged, its correct functioning can be assumed while the second layer is
debugged, and so on. If an error is found during the debugging of a particular
layer, the error must be on that layer, because the layers below it are already
debugged. Thus, the design and implementation of the system are simplified.

Each layer is implemented only with operations provided by lower-level
layers. A layer does not need to know how these operations are implemented;
it needs to know only what these operations do. Hence, each layer hides the
existence of certain data structures, operations, and hardware from higher-level
layers.
====PAGE==== 45
A final problem with layered implementations is that they tend to be less
efficient than other types. For instance, when a user program executes an I/O
operation, it executes a system call that is trapped to the I/O layer, which calls
the memory-management layer, which in turn calls the CPU-scheduling layer,
which is then passed to the hardware. At each layer, the parameters may be
modified, data may need to be passed, and so on. Each layer adds overhead to
the system call. The net result is a system call that takes longer than does one
on a nonlayered system.

These limitations have caused a small backlash against layering in recent
years. Fewer layers with more functionality are being designed, providing
most of the advantages of modularized code while avoiding the problems of
layer definition and interaction.
====PAGE==== 46
One benefit of the microkernel approach is that it makes extending
the operating system easier. All new services are added to user space and
consequently do not require modification of the kernel. When the kernel does
have to be modified, the changes tend to be fewer, because the microkernel is
a smaller kernel. The resulting operating system is easier to port from one
hardware design to another. The microkernel also provides more security
and reliability, since most services are running as user--rather than kernel--
processes. If a service fails, the rest of the operating system remains untouched.

Some contemporary operating systems have used the microkernel
approach. Tru64 UNIX (formerly Digital UNIX) provides a UNIX interface to the
user, but it is implemented with a Mach kernel. The Mach kernel maps UNIX
system calls into messages to the appropriate user-level services. The Mac OS X
kernel (also known as Darwin) is also partly based on the Mach microkernel.
====PAGE==== 47
Another example is QNX, a real-time operating system for embedded
systems. The QNX Neutrino microkernel provides services for message passing
and process scheduling. It also handles low-level network communication
and hardware interrupts. All other services in QNX are provided by standard
processes that run outside the kernel in user mode.

Unfortunately, the performance of microkernels can suffer due to increased
system-function overhead. Consider the history of Windows NT. The first
release had a layered microkernel organization. This version's performance
was low compared with that of Windows 95. Windows NT 4.0 partially
corrected the performance problem by moving layers from user space to
kernel space and integrating them more closely. By the time Windows XP
was designed, Windows architecture had become more monolithic than
microkernel.
====PAGE==== 48
Perhaps the best current methodology for operating-system design involves
using loadable kernel modules. Here, the kernel has a set of core components
and links in additional services via modules, either at boot time or during run
time. This type of design is common in modern implementations of UNIX, such
as Solaris, Linux, and Mac OS X, as well as Windows.

The idea of the design is for the kernel to provide core services while
other services are implemented dynamically, as the kernel is running. Linking
services dynamically is preferable to adding new features directly to the kernel,
which would require recompiling the kernel every time a change was made.
Thus, for example, we might build CPU scheduling and memory management
algorithms directly into the kernel and then add support for different file
systems by way of loadable modules.
====PAGE==== 49
Linux is used primarily for process, memory, and device-driver support for
hardware and has been expanded to include power management. The Android
runtime environment includes a core set of libraries as well as the Dalvik Virtual
machine. Software designers for Android devices develop applications in the
Java Language. However, rather than using the standard Java API, Google has
designed a separate Android API for Java development. The Java class files are
first compiled to Java bytecode and then translated into an executable file that
runs on the DAlvik virtual machine. The Dalvik virtual machine was designed
for Android and is optimized for mobile devices with limited memory and
CPU processing capabilities.

The set of libraries available for Android applications includes frameworks
for developing web browsers (webkit), database support (SQLite), and multi-
media. The libc library is similar to the standard C library but is much smaller
and has been designed for the slower CPUs that characterize mobile devices.
====PAGE==== 50
If a process fails, most operating systems write the error information to a log
file to alert system operators or users that the problem occurred. The operating
system can also take a core dump--a capture of the memory of the process--
and store it in a file for later analysis. (Memory was referred to as the "core"
in the early days of computing.) Running programs and core dumps can be
probed by a debugger, which allows a programmer to explore the code and
memory of a process.

Debugging user-level process code is a challenge. Operating-system kernel
debugging is even more complex because of the size and complexity of the
kernel, its control of the hardware, and the lack of user-level debugging tools.
A failure in the kernel is called a crash. When a crash occurs, error information
is saved to a log file, and the memory state is saved to a crash dump.
====PAGE==== 51
Debugging the interactions between user-level and kernel code is nearly
impossible without a toolset that understands both sets of code and can
instrument the interactions. For that toolset to be truly useful, it must be able
to debug any area of a system, including areas that were not written with
debugging in mind, and do so without affecting system reliability. This tool
must also have a minimum performance impact--ideally it should have no
impact when not in use and a proportional impact during use. The DTrace tool
meets these requirements and provides a dynamic, safe, low-impact debugging
environment.

Until the DTrace framework and tools became available with Solaris 10,
kernel debugging was usually shrouded in mystery and accomplished via
happenstance and archaic code and tools. For example, CPUs have a breakpoint
feature that will halt execution and allow a debugger to examine the state of the
system. Then execution can continue until the next breakpoint or termination.
This method cannot be used in a multiuser operating-system kernel without
negatively affecting all of the users on the system. Profiling, which periodically
samples the instruction pointer to determine which code is being executed, can
show statistical trends but not individual activities. Code can be included in
the kernel to emit specific data under specific circumstances, but that code
slows down the kernel and tends not to be in the part of the kernel
where the specific problem being debugged is occurring.
====PAGE==== 52
In contrast, DTrace runs on production systems--systems that are running
important or critical applications--and causes no harm to the system. It
slows activities while enabled, but after execution it resets the system to its
pre-debugging state. It is also a broad and deep tool. It can broadly debug
everything happening in the system (both at the user and kernel levels and
between the user and kernel layers). It can also delve deep into code, showing
individual CPU instructions or kernel subroutine activities.

DTrace is composed of a compiler, a framework, providers of probes
written within that framework, and consumers of those probes. DTrace
providers create probes. Kernel structures exist to keep track of all probes that
the providers have created. The probes are stored in a hash-table data structure
that is hashed by name and indexed according to unique probe identifiers.
When a probe is enabled, a bit of code in the area to be probed is rewritten
to call dtrace_probe(probe identifier) and then continue with the code's
original operation. Different providers create different kinds of probes. For
example, a kernel system-call probe works differently from a user-process
probe, and that is different from an I/O probe.
====PAGE==== 53
A DTrace consumer is code that is interested in a probe and its results.
A consumer requests that the provider create one or more probes. When a
probe fires, it emits data that are managed by the kernel. Within the kernel,
actions called enabling control blocks, or ECBs, are performed when probes
fire. One probe can cause multiple ECBs to execute if more than one consumer
is interested in that probe. Each ECB contains a predicate ("if statement") that
can filter out that ECB. Otherwise, the list of actions in the ECB is executed. The
most common action is to capture some bit of data, such as a variable's value at
that point of the probe execution. By gathering such data, a complete picture of
a user or kernel action can be built. Further, probes firing from both user space
and the kernel can show how a user-level action caused kernel-level reactions.
Such data are invaluable for performance monitoring and code optimization.

Once the probe consumer terminates, its ECBs are removed. If there are no
ECBs consuming a probe, the probe is removed. That involves rewriting the
code to remove the dtrace_probe() call and put back the original code. Thus,
before a probe is created and after it is destroyed, the system is exactly the
same, as if no probing occurred.
====PAGE==== 54
It is possible to design, code, and implement an operating system specifically
for one machine at one site. More commonly, however, operating systems
are designed to run on any of a class of machines at a variety of sites with
a variety of peripheral configurations. The system must then be configured
or generated for each specific computer site, a process sometimes known as
system generation SYSGEN.

The operating system is normally distributed on disk, on CD-ROM or DVD-ROM, or
as an "ISO" image, which is a file in the format of a CD-ROM
or DVD-ROM. To generate a system, we use a special program. This SYSGEN
program reads from a given file, or asks the operator of the system for
information concerning the specific configuration of the hardware system, or
probes the hardware directly to determine what components are there. The
following kinds of information must be determined.
====PAGE==== 55
A process can be thought of as a program in execution. A process will
need certain resources--such as CPU time, memory, files, and I/O devices
--to accomplish its task. These resources are allocated to the process
either when it is created or while it is executing.

A process is the unit of work in most systems. Systems consist of
a collection of processes; operating-system processes execute system
code, and user processes execute user code. All these processes may
execute concurrently.

Although traditionally a process contained only a single thread of
control as it ran, most modern operating systems now support processes
that have multiple threads.

The operating system is responsible for several important aspects
of process and thread management: the creation and deletion of both user
and system processes; the scheduling of processes; and the provision of
mechanisms for synchronization, communication, and deadlock handling
for processes.
====PAGE==== 56
Early computers allowed only one program to be executed at a time. This
program had complete control of the system and had access to all the system's
resources. In contrast, contemporary computer systems allow multiple pro-
grams to be loaded into memory and executed concurrently. This evolution
required firmer control and more compartmentalization of the various pro-
grams; and these needs resulted in the notion of a process, which is a program
in execution. A process is the unit of work in a modern time-sharing system.

The more complex the operating system is, the more it is expected to do on
behalf of its users. Although its main concern is the execution of user programs,
it also needs to take care of various system tasks that are better left outside the
kernel itself. A system therefore consists of a collection of processes; operating-
system processes executing system code and user processes executing user
code. Potentially, all these processes can execute concurrently, with the CPU (or
CPUs) multiplexed among them. By switching the CPU between processes, the
operating system can make the computer more productive. In this chapter, you
will read about what processes are and how they work.
====PAGE==== 57 —
As processes enter the system, they are put into a job queue, which consists
of all processes in the system. The processes that are residing in main memory
and are ready and waiting to execute are kept on a list called the ready queue.
This queue is generally stored as a linked list. A ready-queue header contains
pointers to the first and final PCBs in the list. Each PCB includes a pointer field
that points to the next PCB in the ready queue.

The system also includes other queues. When a process is allocated the
CPU, it executes for a while and eventually quits, is interrupted, or waits for
the occurrence of a particular event, such as the completion of an I/O request.
Suppose the process makes an I/O request to a shared device, such as a disk.
====PAGE==== 58
The long-term scheduler executes much less frequently; minutes may sep-
arate the creation of one new process and the next. The long-term scheduler
controls the degree of multiprogramming (the number of processes in mem-
ory). If the degree of multiprogramming is stable, then the average rate of
process creation must be equal to the average departure rate of processes
leaving the system. Thus, the long-term scheduler may need to be invoked
only when a process leaves the system. Because of the longer interval between
executions, the long-term scheduler can afford to take more time to decide
which process should be selected for execution.
====PAGE==== 58
It is important that the long-term scheduler make a careful selection. In
general, most processes can be described as either I/O bound or CPU bound.
An I/O-bound process is one that spends more of its time doing I/O than
it spends doing computations. A CPU-bound process, in contrast, generates
I/O requests infrequently, using more of its time doing computations. It is
important that the long-term scheduler select a good process mix of I/O-bound
and CPU-bound processes. If all processes are I/O bound, the ready queue will
almost always be empty and the short-term scheduler will have little to do.
If all processes are CPU bound, the I/O waiting queue will almost always be
empty, devices will go unused, and again the system will be unbalanced. The
system with the best performance will thus have a combination of CPU-bound
and I/O-bound processes.
====PAGE==== 60
Context-switch times are highly dependent on hardware support. For
instance, some processors (such as the Sun UltraSPARC) provide multiple sets
of registers. A context switch here simply requires changing the pointer to the
current register set. Of course, if there are more active processes than there are
register sets, the system resorts to copying register data to and from memory,
as before. Also, the more complex the operating system, the greater the amount
of work that must be done during a context switch. As we will see in Chapter
8, advanced memory-management techniques may require that extra data be
switched with each context. For instance, the address space of the current
process must be preserved as the space of the next task is prepared for use.
How the address space is preserved, and what amount of work is needed
to preserve it, depend on the memory-management method of the operating
system.
